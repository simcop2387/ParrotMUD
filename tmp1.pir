# generated by luac.pl

.include 'interpinfo.pasm'
.HLL 'Lua', 'lua_group'

.sub '__start' :anon :main
    .param pmc args
#    print "start Lua\n"
    sweepoff
    load_bytecode 'languages/lua/lib/luaaux.pbc'
    load_bytecode 'languages/lua/lib/luabasic.pbc'
    load_bytecode 'languages/lua/lib/luacoroutine.pbc'
    load_bytecode 'languages/lua/lib/luapackage.pbc'
    load_bytecode 'languages/lua/lib/luastring.pbc'
    load_bytecode 'languages/lua/lib/luaregex.pbc'
    load_bytecode 'languages/lua/lib/luatable.pbc'
    load_bytecode 'languages/lua/lib/luamath.pbc'
    load_bytecode 'languages/lua/lib/luaio.pbc'
    load_bytecode 'languages/lua/lib/luafile.pbc'
    load_bytecode 'languages/lua/lib/luaos.pbc'
    load_bytecode 'languages/lua/lib/luadebug.pbc'
    load_bytecode 'languages/lua/lib/luaperl.pbc'
    lua_openlibs()
    .local pmc env
    env = get_hll_global '_G'
    .local pmc vararg
    vararg = argstolua(env, args)
    .const .Sub main = '_main'
    main.'setfenv'(env)
    ($I0, $P0) = docall(main, vararg :flat)
    unless $I0 goto L1
    printerr 'luac.pl: '
    printerr $P0
  L1:
.end

.sub '_main' :anon :lex :outer(__start)
    .param pmc vararg :slurpy
    $P0 = interpinfo .INTERPINFO_CURRENT_SUB
    .local pmc env
    .const .LuaString k_complex = 'complex'
    .const .LuaString k_new = 'new'
    .const .LuaString k_i = 'i'
    $P5 = new 'LuaNumber'
    set $P5, 0
    $P6 = new 'LuaNumber'
    set $P6, 1
    .const .LuaString k_new = 'new'
    .const .LuaString k_add = 'add'
    .const .LuaString k_sub = 'sub'
    .const .LuaString k_mul = 'mul'
    .local pmc var_8_inv
    .lex 'var_8_inv', var_8_inv
    .const .LuaString k_div = 'div'
    # end of prolog
    env = $P0.'getfenv'()
    $P1 = new 'LuaTable'
    env[k_complex] = $P1
    $P3 = env[k_complex]
    .const .Sub fct_0 = 'fct_0'
    $P2 = newclosure fct_0
    $P2.'setfenv'(env)
    $P3[k_new] = $P2
    $P4 = env[k_complex]
    $P7 = env[k_complex]
    $P8 = $P7[k_new]
    $P9 = new 'LuaNil'
    ($P9) = $P8($P5, $P6)
    $P4[k_i] = $P9
    env = $P0.'getfenv'()
    $P11 = env[k_complex]
    .const .Sub fct_1 = 'fct_1'
    $P10 = newclosure fct_1
    $P10.'setfenv'(env)
    $P11[k_add] = $P10
    $P13 = env[k_complex]
    .const .Sub fct_2 = 'fct_2'
    $P12 = newclosure fct_2
    $P12.'setfenv'(env)
    $P13[k_sub] = $P12
    $P15 = env[k_complex]
    .const .Sub fct_3 = 'fct_3'
    $P14 = newclosure fct_3
    $P14.'setfenv'(env)
    $P15[k_mul] = $P14
    .const .Sub fct_4 = 'fct_4'
    $P16 = newclosure fct_4
    $P16.'setfenv'(env)
    store_lex 'var_8_inv', $P16
    $P18 = env[k_complex]
    .const .Sub fct_5 = 'fct_5'
    $P17 = newclosure fct_5
    $P17.'setfenv'(env)
    $P18[k_div] = $P17
    $P19 = env[k_complex]
    .return ($P19)
.end

.sub 'fct_5' :anon :lex :outer(_main)
    .param pmc var_1_c1 :optional
    .param pmc var_1_c2 :optional
    .param pmc extra :slurpy
    .lex 'var_1_c1', var_1_c1
    unless null var_1_c1 goto L9
    var_1_c1 = new 'LuaNil'
  L9:
    .lex 'var_1_c2', var_1_c2
    unless null var_1_c2 goto L10
    var_1_c2 = new 'LuaNil'
  L10:
    $P2 = interpinfo .INTERPINFO_CURRENT_SUB
    .local pmc env
    .const .LuaString k_complex = 'complex'
    .const .LuaString k_mul = 'mul'
    # end of prolog
    $P0 = find_lex 'var_8_inv'
    $P1 = new 'LuaNil'
    ($P1 :slurpy) = $P0(var_1_c2)
    env = $P2.'getfenv'()
    $P3 = env[k_complex]
    $P4 = $P3[k_mul]
    .return $P4(var_1_c1, $P1 :flat)
.end

.sub 'fct_4' :anon :lex :outer(_main)
    .param pmc var_1_c :optional
    .param pmc extra :slurpy
    .lex 'var_1_c', var_1_c
    unless null var_1_c goto L8
    var_1_c = new 'LuaNil'
  L8:
    .local pmc var_1_n
    .lex 'var_1_n', var_1_n
    .const .LuaString k_r = 'r'
    $P1 = new 'LuaNumber'
    set $P1, 2
    .const .LuaString k_i = 'i'
    $P11 = interpinfo .INTERPINFO_CURRENT_SUB
    .local pmc env
    .const .LuaString k_complex = 'complex'
    .const .LuaString k_new = 'new'
    # end of prolog
    $P0 = var_1_c[k_r]
    $P2 = pow $P0, $P1
    $P3 = var_1_c[k_i]
    $P4 = pow $P3, $P1
    $P5 = add $P2, $P4
    store_lex 'var_1_n', $P5
    $P6 = var_1_c[k_r]
    $P7 = div $P6, var_1_n
    $P8 = var_1_c[k_i]
    $P9 = neg $P8
    $P10 = div $P9, var_1_n
    env = $P11.'getfenv'()
    $P12 = env[k_complex]
    $P13 = $P12[k_new]
    .return $P13($P7, $P10)
.end

.sub 'fct_3' :anon :lex :outer(_main)
    .param pmc var_1_c1 :optional
    .param pmc var_1_c2 :optional
    .param pmc extra :slurpy
    .lex 'var_1_c1', var_1_c1
    unless null var_1_c1 goto L6
    var_1_c1 = new 'LuaNil'
  L6:
    .lex 'var_1_c2', var_1_c2
    unless null var_1_c2 goto L7
    var_1_c2 = new 'LuaNil'
  L7:
    .const .LuaString k_r = 'r'
    .const .LuaString k_i = 'i'
    $P14 = interpinfo .INTERPINFO_CURRENT_SUB
    .local pmc env
    .const .LuaString k_complex = 'complex'
    .const .LuaString k_new = 'new'
    # end of prolog
    $P0 = var_1_c1[k_r]
    $P1 = var_1_c2[k_r]
    $P2 = mul $P0, $P1
    $P3 = var_1_c1[k_i]
    $P4 = var_1_c2[k_i]
    $P5 = mul $P3, $P4
    $P6 = sub $P2, $P5
    $P7 = var_1_c1[k_r]
    $P8 = var_1_c2[k_i]
    $P9 = mul $P7, $P8
    $P10 = var_1_c1[k_i]
    $P11 = var_1_c2[k_r]
    $P12 = mul $P10, $P11
    $P13 = add $P9, $P12
    env = $P14.'getfenv'()
    $P15 = env[k_complex]
    $P16 = $P15[k_new]
    .return $P16($P6, $P13)
.end

.sub 'fct_2' :anon :lex :outer(_main)
    .param pmc var_1_c1 :optional
    .param pmc var_1_c2 :optional
    .param pmc extra :slurpy
    .lex 'var_1_c1', var_1_c1
    unless null var_1_c1 goto L4
    var_1_c1 = new 'LuaNil'
  L4:
    .lex 'var_1_c2', var_1_c2
    unless null var_1_c2 goto L5
    var_1_c2 = new 'LuaNil'
  L5:
    .const .LuaString k_r = 'r'
    .const .LuaString k_i = 'i'
    $P6 = interpinfo .INTERPINFO_CURRENT_SUB
    .local pmc env
    .const .LuaString k_complex = 'complex'
    .const .LuaString k_new = 'new'
    # end of prolog
    $P0 = var_1_c1[k_r]
    $P1 = var_1_c2[k_r]
    $P2 = sub $P0, $P1
    $P3 = var_1_c1[k_i]
    $P4 = var_1_c2[k_i]
    $P5 = sub $P3, $P4
    env = $P6.'getfenv'()
    $P7 = env[k_complex]
    $P8 = $P7[k_new]
    .return $P8($P2, $P5)
.end

.sub 'fct_1' :anon :lex :outer(_main)
    .param pmc var_1_c1 :optional
    .param pmc var_1_c2 :optional
    .param pmc extra :slurpy
    .lex 'var_1_c1', var_1_c1
    unless null var_1_c1 goto L2
    var_1_c1 = new 'LuaNil'
  L2:
    .lex 'var_1_c2', var_1_c2
    unless null var_1_c2 goto L3
    var_1_c2 = new 'LuaNil'
  L3:
    .const .LuaString k_r = 'r'
    .const .LuaString k_i = 'i'
    $P6 = interpinfo .INTERPINFO_CURRENT_SUB
    .local pmc env
    .const .LuaString k_complex = 'complex'
    .const .LuaString k_new = 'new'
    # end of prolog
    $P0 = var_1_c1[k_r]
    $P1 = var_1_c2[k_r]
    $P2 = add $P0, $P1
    $P3 = var_1_c1[k_i]
    $P4 = var_1_c2[k_i]
    $P5 = add $P3, $P4
    env = $P6.'getfenv'()
    $P7 = env[k_complex]
    $P8 = $P7[k_new]
    .return $P8($P2, $P5)
.end

.sub 'fct_0' :anon :lex :outer(_main)
    .param pmc var_1_r :optional
    .param pmc var_1_i :optional
    .param pmc extra :slurpy
    .lex 'var_1_r', var_1_r
    unless null var_1_r goto L0
    var_1_r = new 'LuaNil'
  L0:
    .lex 'var_1_i', var_1_i
    unless null var_1_i goto L1
    var_1_i = new 'LuaNil'
  L1:
    .const .LuaString k_r = 'r'
    .const .LuaString k_i = 'i'
    # end of prolog
    $P0 = new 'LuaTable'
    $P0[k_r] = var_1_r
    $P0[k_i] = var_1_i
    .return ($P0)
.end

